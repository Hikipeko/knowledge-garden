### 4.1 Message Integrity

We want to detect if a message is modified by an adversary.  In general, encryption doesn't provide any integrity.



### 4.2 Message Authentication Codes (MACs) - Definitions

The aim of MAC is to prevent an adversary from modifying a message sent by one party to another.

##### Definition 4.1 MAC

A MAC consists of three p.p.t. algorithms (Gen, Mac, Vrfy) such that:

1. $\sf Gen$ takes as input the security parameter $1^n$ and outputs a key $k$ with $|k| > n$.
2. The tag generation algorithm $\sf Mac$ takes as input $k$ and $m$ and outputs a tag $t \leftarrow {\sf Mac}_k(m)$.
3. The *deterministic* verification algorithm $\sf Vrfy$ outputs a valid bit $b = {\sf Vrfy}_k(m, t)$. We require that ${\sf Vrfy}_k(m, {\sf Mac}_k(m)) = 1$.

A canonical way to verify is to compute the tag and check for equality.

##### Definition 4.2 Security of MAC

**The message authentication experiment** $\text{Mac-forge}_{{\cal A}, \Pi}(n)$:

1. A key $k$ is generated by running $\sf Gen$.
2. $\cal A$ is given $1^n$ and oracle access to ${\sf Mac}_k(\cdot)$. $\cal A$ outputs $(m,t)$.
3. $\cal A$ succeeds iff. ${\sf Vrfy}(m,t)=1$ and $m$ isn't queried before.

A MAC is **existentially unforgeable under an adaptive chosen-message attack** if for all p.p.t. $\cal A$, there is negligible function such that:
$$
\Pr[\text{Mac-forge}_{{\cal A}, \Pi}(n)=1]\leq {\sf negl}(n).
$$
This security definition offers no protection against replay attackers. Sequence numbers and time-stamps can be used to prevent this attack.

##### Definition 4.3 Strong Unforgeability

We want a stronger security such that an adversary cannot generate a valid tag on a previously authenticated message. The definition of **strongly secure** is exactly the same as the previous one, except that we let $\cal A$ succeed iff ${\sf Vrfy}(m,t)=1$ and $(m,t)$ isn't a pair of oracle queries.

**Proposition 4.4** If s MAC that uses canonical verification is a secure, then it's strongly secure.

Still cannot protect against timing attack, where the attacker measures the time to accept a tag and progressively recover the tag. MAC should use time-independent string comparison.



### 4.3 Constructing Secure MAC

#### 4.3.1 A Fixed-Length MAC

##### Theorem 4.6 Secure MAC

**Construction**: Use a PRF $F_k$ as both the $\sf Mac$ and $\sf Vrfy$ function. If $F_k$ is a PRF, then the construction is a secure fixed-length MAC.

![[Pasted image 20230225221525.png]]

#### 4.3.2 Domain Extension for MACs

How do we extend the above construction to arbitrary length message?

1. Parse $m$ into chunks and authenticate each block separately: block re-ordering attack
2. Use $t_i = {\sf Mac}'_k(i||m_i)$: truncation attack (drop ending blocks)
3. Use $t_i = {\sf Mac}'_k(l||i||m_i)$ where $l$ is the message length: mix and match attack (aa & bb -> ab)

##### Theorem 4.8 Secure MAC

**Construction 4.7** Define a MAC as follows:

1. On input $m$ of length $l < 2^{n/4}$, parse $m$ as $d$ blocks each of length $n/4$.
2. Choose random $r$.
3. Compute $t_i \leftarrow {\sf Mac}'_k(r||l||i||m_i)$.
4. Output the tag $t := \langle 4, t_1, t_2, ...,t_d \rangle$.

If ${\sf Mac}'$ is a secure fixed-length MAC, then construction 4.7 is a secure MAC for arbitrary-length messages.



### 4.4 CBC-MAC

#### 4.4.1 The Basic Construction

Construction 4.7 is too long, and is not practical.

**Construction 4.9** Let $F$ be a PRF, and fix a length function $l(n) > 0$.

* **Mac**: on input $k$, $m$ with length $l(n)\cdot n$, first parse $m$ as $m_1, ..., m_l$. Set $t_0 := 0^n$. Then for $i = 1$ to $l$, set $t_i = F_k(t_{i-1} \oplus m_i)$. Output $t_l$ as the tag.
* **Vrfy**: on input $k$, $m$, $t$, output 1 if $|m| = l(n) \cdot n$ and $t = {\sf Mac}_k(m)$.

**Theorem 4.10** Let $l$ by a polynomial. If $F$ is a PRF, then Construction 4.9 is secure MAC for message of length $l(n) \cdot n$.

Compared with [[3 Private-Key Encryption 475#Cipher Block Chaining (CBC) Mode|CBC-mode encryption]], CBC-MAC uses no IV, and outputs only the final block. These two properties are crucial for MAC security.

##### Secure CBC-MAC for arbitrary-length messages

1. Prepend the message $m$ with its length $|m|$.
2. Use two private keys, one for CBC-MAC, another for $\hat t := F_{k_2}(t)$.

#### 4.4.2 Proof of Security

**Prefix-free** string is the set of string such that no string $X$ is a prefix of any other string $X'$. Prepend length + append 0 is a possible encoding which is prefix-free.

**Theorem 4.11** Define ${\sf CBC}_k(x_1, ..., x_l) := F_k(F_k(\cdots F_k(F_k(x_1)\oplus x_2)\oplus \cdots )\oplus x_l)$. If $F$ is a PRF, then $\sf CBC$ is also a PRF as long as the input set is prefix-free.
